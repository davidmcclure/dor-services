#!/usr/bin/env ruby

require 'rubygems'
require 'optparse'
require 'stomp'
require 'dor-services'

options = {}

optparse = OptionParser.new do|opts|
  opts.banner = "Usage: #{File.basename(__FILE__)} [options]"

  options[:dor_config] = nil
  opts.on( '--dor-config PATH', 'Load the dor-services configuration file at this path' ) do |path|
    options[:dor_config] = path
  end

  options[:port] = 61613
  opts.on('-p','--port NUM', 'Stomp port') do |port|
    options[:port] = port
  end

  options[:host] = 'localhost'
  opts.on('-o','--host HOSTNAME', 'Host to connect to') do |host|
    options[:host] = host
  end

  options[:user] = 'fedoraStomper'
  opts.on('-u', '--user USERNAME', 'User name for stomp listener') do |user|
    options[:user] = user
  end

  options[:password] = 'fedoraStomper'
  opts.on('-w', '--password PASSWORD', 'Password for stomp listener') do |password|
    options[:password] = password
  end

  options[:destination] = '/topic/fedora.apim.update'
  opts.on('-d','--destination TOPIC', 'Topic to listen to') do |destination|
    options[:destination] = destination
  end

  options[:client_id] = "fedora_stomper"
  opts.on('-c', '--client-id ID', 'Stomp client ID') do |client_id|
    options[:client_id] = client_id
  end
  
  opts.on('-h', '--help', 'Display this screen') do
    puts opts
    exit
  end
end

optparse.parse!

begin; require 'rubygems'; rescue; end

if options[:dor_config]
  puts "Configuring dor-services..."
  require options[:dor_config]
else
  $stderr.puts "The --dor-config PATH option is mandatory. Please provide the path to a valid dor-services configuration file."
  exit 1
end

puts "loading listener"

begin
  @port = options[:port] 
  @host = options[:host]
  @user = options[:user]
  @password = options[:password]
  @reliable = true
  @clientid = options[:client_id]
  @destination = options[:destination]


  $stderr.print "Connecting to stomp://#{@host}:#{@port} as #{@user}\n"
  @conn = Stomp::Connection.open(@user, @password, @host, @port, @reliable, 5, {"client-id" => @clientid} )
  $stderr.print "Getting output from #{@destination}\n"
  
  @conn.subscribe(@destination, {"activemq.subscriptionName" => @clientid, :ack =>"client" })
  while true
      @msg = @conn.receive
      pid = @msg.headers["pid"]
      method = @msg.headers["methodName"]

      puts @msg.headers.inspect
      puts "\nPID: #{@msg.headers["pid"]}\n"
      if ["addDatastream", "addRelationship","ingest","modifyDatastreamByValue","modifyDatastreamByReference","modifyObject","purgeDatastream","purgeRelationship"].include? method
        begin
          obj = Dor.load_instance @msg.headers["pid"]
          Dor::SearchService.solr.add(obj.to_solr, :add_attributes => {:commitWithin => 10}) unless obj.nil?
        rescue
        end
      elsif method == "purgeObject"
        Dor::SearchService.solr.delete_by_id(pid)
      else
        $stderr.puts "Unknown Method: #{method}"
      end
      puts  "updated solr index for #{@msg.headers["pid"]}\n"
      @conn.ack @msg.headers["message-id"]
  end
  @conn.join

rescue Exception => e
p e
end

